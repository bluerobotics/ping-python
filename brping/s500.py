#!/usr/bin/env python3

# s500.py
# A device API for the Cerulean Sonar S500 sonar

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from brping import definitions
from brping import PingDevice
from brping import pingmessage
import time
import struct
import socket
from datetime import datetime, timezone
from pathlib import Path

# Imports for svlog header
import json
import sys
import platform

MAX_LOG_SIZE_MB = 500

class S500(PingDevice):
    def __init__(self, logging = False, log_directory = None):
        super().__init__()
        self.logging = logging
        self.log_directory = log_directory
        self.bytes_written = None
        self.current_log = None

    def initialize(self):
        if (self.readDeviceInformation() is None):
            return False
        if self.logging:
            self.new_log(self.log_directory)
        return True

    ##
    # @brief Get a altitude message from the device\n
    # Message description:\n
    # 
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # altitude_mm: Units: mm; Result of most recent calculated distance from device to bottom (or other target).\n
    # quality: Measure of confidence of altitude measure, 0 (No idea) to 100 (Quite sure).\n
    def get_altitude(self):
        if self.request(definitions.S500_ALTITUDE) is None:
            return None
        data = ({
            "altitude_mm": self._altitude_mm,  # Units: mm; Result of most recent calculated distance from device to bottom (or other target).
            "quality": self._quality,  # Measure of confidence of altitude measure, 0 (No idea) to 100 (Quite sure).
        })
        return data

    ##
    # @brief Get a distance2 message from the device\n
    # Message description:\n
    # Reports a simple distance measurement.
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # ping_distance_mm: Units: mm; Distance of most recent ping\n
    # averaged_distance_mm: Units: mm; Average distance over last 20 pings\n
    # reserved: \n
    # ping_confidence: 0 to 100\n
    # average_distance_confidence: 0 to 100\n
    # timestamp: Units: msec; \n
    def get_distance2(self):
        if self.request(definitions.S500_DISTANCE2) is None:
            return None
        data = ({
            "ping_distance_mm": self._ping_distance_mm,  # Units: mm; Distance of most recent ping
            "averaged_distance_mm": self._averaged_distance_mm,  # Units: mm; Average distance over last 20 pings
            "reserved": self._reserved,  # 
            "ping_confidence": self._ping_confidence,  # 0 to 100
            "average_distance_confidence": self._average_distance_confidence,  # 0 to 100
            "timestamp": self._timestamp,  # Units: msec; 
        })
        return data

    ##
    # @brief Get a fw_version message from the device\n
    # Message description:\n
    # 
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # device_type: \n
    # device_model: \n
    # version_major: \n
    # version_minor: \n
    def get_fw_version(self):
        if self.request(definitions.S500_FW_VERSION) is None:
            return None
        data = ({
            "device_type": self._device_type,  # 
            "device_model": self._device_model,  # 
            "version_major": self._version_major,  # 
            "version_minor": self._version_minor,  # 
        })
        return data

    ##
    # @brief Get a gain_index message from the device\n
    # Message description:\n
    # 
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # gain_index: Current gain index setting\n
    def get_gain_index(self):
        if self.request(definitions.S500_GAIN_INDEX) is None:
            return None
        data = ({
            "gain_index": self._gain_index,  # Current gain index setting
        })
        return data

    ##
    # @brief Get a ping_rate_msec message from the device\n
    # Message description:\n
    # 
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # msec_per_ping: Units: msec; Minimum time between successive pings. Can be longer depending on range.\n
    def get_ping_rate_msec(self):
        if self.request(definitions.S500_PING_RATE_MSEC) is None:
            return None
        data = ({
            "msec_per_ping": self._msec_per_ping,  # Units: msec; Minimum time between successive pings. Can be longer depending on range.
        })
        return data

    ##
    # @brief Get a processor_degC message from the device\n
    # Message description:\n
    # 
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # centi_degC: Units: centi-degrees C; Device CPU temperature, result = degrees C * 100\n
    def get_processor_degC(self):
        if self.request(definitions.S500_PROCESSOR_DEGC) is None:
            return None
        data = ({
            "centi_degC": self._centi_degC,  # Units: centi-degrees C; Device CPU temperature, result = degrees C * 100
        })
        return data

    ##
    # @brief Get a profile6_t message from the device\n
    # Message description:\n
    # Reports a measure of signal strength at all depths within the ping range. This could be used to present a 'waterfall' type display similar to a commercial marine depth sounder or fish finder. The Cerulean SonarView app uses profile6_t to do just that. The native number of results reported for the profile6_t is 1024 for monotone pings. For chirp pings, the range resolution is affected by the 'decimation' field in the set_ping_params command. If decimation is set to 0, the device will vary decimation depending on range. The smallest decimation will be used that does not exceed 6000 reported data elements. Keep in mind the bandwidth of the communication channel in use when considering which profile report to use. For example, profile6_t can generate a lot of data, and is probably best used with the USB or Ethernet interface.
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # ping_number: Sequentially assigned from 0 at power up.\n
    # start_mm: Units: mm; Start of ping range\n
    # length_mm: Units: mm; Length of the returned profile. End of range = start_mm + length_mm.\n
    # start_ping_hz: Units: hz; Initial frequency of ping.\n
    # end_ping_hz: Units: hz; Final frequency of ping.\n
    # adc_sample_hz: Units: hz; Sampling rate of adc\n
    # timestamp_msec: Units: msec; \n
    # spare2: \n
    # pulse_duration_sec: Units: sec; Pulse duration in seconds.\n
    # analog_gain: \n
    # max_pwr_db: Units: dB; Maximum power level in dB.\n
    # min_pwr_db: Units: dB; Minimum power level in dB.\n
    # this_ping_depth_m: Units: m; Depth in meters as calculated from most recent ping.\n
    # smooth_depth_m: Units: m; Smoothed calculated depth in meters.\n
    # fspare2: 0\n
    # ping_depth_measurement_confidence: Depth measurement confidence (0-100) based on most recent ping.\n
    # gain_index: \n
    # decimation: \n
    # smoothed_depth_measurement_confidence: 0 (0-100)\n
    # num_results: \n
    # pwr_results: Power results scaled from min_pwr to max_pwr. num_results entries.\n
    def get_profile6_t(self):
        if self.request(definitions.S500_PROFILE6_T) is None:
            return None
        data = ({
            "ping_number": self._ping_number,  # Sequentially assigned from 0 at power up.
            "start_mm": self._start_mm,  # Units: mm; Start of ping range
            "length_mm": self._length_mm,  # Units: mm; Length of the returned profile. End of range = start_mm + length_mm.
            "start_ping_hz": self._start_ping_hz,  # Units: hz; Initial frequency of ping.
            "end_ping_hz": self._end_ping_hz,  # Units: hz; Final frequency of ping.
            "adc_sample_hz": self._adc_sample_hz,  # Units: hz; Sampling rate of adc
            "timestamp_msec": self._timestamp_msec,  # Units: msec; 
            "spare2": self._spare2,  # 
            "pulse_duration_sec": self._pulse_duration_sec,  # Units: sec; Pulse duration in seconds.
            "analog_gain": self._analog_gain,  # 
            "max_pwr_db": self._max_pwr_db,  # Units: dB; Maximum power level in dB.
            "min_pwr_db": self._min_pwr_db,  # Units: dB; Minimum power level in dB.
            "this_ping_depth_m": self._this_ping_depth_m,  # Units: m; Depth in meters as calculated from most recent ping.
            "smooth_depth_m": self._smooth_depth_m,  # Units: m; Smoothed calculated depth in meters.
            "fspare2": self._fspare2,  # 0
            "ping_depth_measurement_confidence": self._ping_depth_measurement_confidence,  # Depth measurement confidence (0-100) based on most recent ping.
            "gain_index": self._gain_index,  # 
            "decimation": self._decimation,  # 
            "smoothed_depth_measurement_confidence": self._smoothed_depth_measurement_confidence,  # 0 (0-100)
            "num_results": self._num_results,  # 
            "pwr_results": self._pwr_results,  # Power results scaled from min_pwr to max_pwr. num_results entries.
        })
        return data

    ##
    # @brief Get a range message from the device\n
    # Message description:\n
    # 
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # start_mm: Units: mm; Normally 0.\n
    # length_mm: Units: mm; start_mm + length_mm is max range.\n
    def get_range(self):
        if self.request(definitions.S500_RANGE) is None:
            return None
        data = ({
            "start_mm": self._start_mm,  # Units: mm; Normally 0.
            "length_mm": self._length_mm,  # Units: mm; start_mm + length_mm is max range.
        })
        return data

    ##
    # @brief Get a speed_of_sound message from the device\n
    # Message description:\n
    # 
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # sos_mm_per_sec: Units: mm/sec; Current speed of sound setting in mm/sec, default is 1500 m/sec.\n
    def get_speed_of_sound(self):
        if self.request(definitions.S500_SPEED_OF_SOUND) is None:
            return None
        data = ({
            "sos_mm_per_sec": self._sos_mm_per_sec,  # Units: mm/sec; Current speed of sound setting in mm/sec, default is 1500 m/sec.
        })
        return data


    def control_set_ping_params(self, start_mm, length_mm, gain_index, msec_per_ping, pulse_len_usec, report_id, reserved, chirp, decimation):
        m = pingmessage.PingMessage(definitions.S500_SET_PING_PARAMS)
        m.start_mm = start_mm
        m.length_mm = length_mm
        m.gain_index = gain_index
        m.msec_per_ping = msec_per_ping
        m.pulse_len_usec = pulse_len_usec
        m.report_id = report_id
        m.reserved = reserved
        m.chirp = chirp
        m.decimation = decimation
        m.pack_msg_data()
        self.write(m.msg_data)

    def control_set_speed_of_sound(self, sos_mm_per_sec):
        m = pingmessage.PingMessage(definitions.S500_SET_SPEED_OF_SOUND)
        m.sos_mm_per_sec = sos_mm_per_sec
        m.pack_msg_data()
        self.write(m.msg_data)


    def readDeviceInformation(self):
        return self.request(definitions.COMMON_DEVICE_INFORMATION)

    ##
    # @brief Do the connection via an TCP link
    #
    # @param host: TCP server address (IPV4) or name
    # @param port: port used to connect with server
    #
    def connect_tcp(self, host: str = None, port: int = 12345):
        if host is None:
            host = '0.0.0.0'
        
        self.server_address = (host, port)
        try:
            print("Opening %s:%d" % self.server_address)
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.iodev.connect(self.server_address)
            self.iodev.setblocking(0)
        
        except Exception as exception:
            raise Exception("Failed to open the given TCP port: {0}".format(exception))

    ##
    # @brief Read available data from the io device
    def read_io(self):
        if self.iodev == None:
            raise Exception("IO device is null, please configure a connection before using the class.")
        elif type(self.iodev).__name__ == 'Serial':
            bytes = self.iodev.read(self.iodev.in_waiting)
            self._input_buffer.extendleft(bytes)
        else: # Socket
            buffer_size = 4096
            while True:
                try: # Check if we are reading before closing a connection
                    bytes = self.iodev.recv(buffer_size)
                    if not bytes:
                        # if recv() returns empty, connection is closed (TCP)
                        if self.iodev.type == socket.SOCK_STREAM:
                            raise ConnectionError("TCP connection closed by peer.")

                    self._input_buffer.extendleft(bytes)

                    if len(bytes) < buffer_size:
                        break

                except BlockingIOError as exception:
                    pass # Ignore exceptions related to read before connection, a result of UDP nature
                
                except ConnectionResetError as e:
                    raise ConnectionError("Socket connection was reset: %s" % str(e))       

    # Converts power results to correct format
    @staticmethod
    def scale_power(msg):
        scaled_power_results = []
        for i in range(len(msg.pwr_results)):
            scaled_power_results.append(msg.min_pwr_db + (msg.pwr_results[i] / 65535.0) * (msg.max_pwr_db - msg.min_pwr_db))
        final_power_results = tuple(scaled_power_results)
        return final_power_results
        
    # Reads a single packet from a file
    @staticmethod
    def read_packet(file):
        sync = file.read(2)
        if sync != b'BR':
            return None
        
        payload_len_bytes = file.read(2)
        if len(payload_len_bytes) < 2:
            return None
        payload_len = int.from_bytes(payload_len_bytes, 'little')

        msg_id = file.read(2)
        if len(msg_id) < 2:
            return None

        remaining = 2 + payload_len + 2
        rest = file.read(remaining)
        if len(rest) < remaining:
            return None

        msg_bytes = sync + payload_len_bytes + msg_id + rest
        return pingmessage.PingMessage(msg_data=msg_bytes)

    # Builds the packet containing metadata for the beginning of .svlog
    def build_metadata_packet(self):
        protocol = "tcp" # default fallback
        if self.iodev:
            if self.iodev.type == socket.SOCK_STREAM:
                protocol = "tcp"
            elif self.iodev.type == socket.SOCK_DGRAM:
                protocol = "udp"
        
        if self.server_address:
            url = f"{protocol}://{self.server_address[0]}:{self.server_address[1]}"
        else:
            url = f"{protocol}://unknown"

        content = {
            "session_id": 1,
            "session_uptime": 0.0,
            "session_devices": [
                {
                    "url": url,
                    "product_id": "s500"
                }
            ],
            "session_platform": None,
            "session_clients": [],
            "session_plan_name": None,

            "is_recording": True,
            "sonarlink_version": "",
            "os_hostname": platform.node(),
            "os_uptime": None,
            "os_version": platform.version(),
            "os_platform": platform.system().lower(),
            "os_release": platform.release(),

            "process_path": sys.executable,
            "process_version": f"v{platform.python_version()}",
            "process_uptime": time.process_time(),
            "process_arch": platform.machine(),

            "timestamp": datetime.now(timezone.utc).isoformat(),
            "timestamp_timezone_offset": datetime.now().astimezone().utcoffset().total_seconds() // 60
        }

        json_bytes = json.dumps(content, indent=2).encode("utf-8")

        m = pingmessage.PingMessage(definitions.OMNISCAN450_JSON_WRAPPER)
        m.payload = json_bytes
        m.payload_length = len(json_bytes)

        msg_data = bytearray()
        msg_data += b"BR"
        msg_data += m.payload_length.to_bytes(2, "little")
        msg_data += m.message_id.to_bytes(2, "little")
        msg_data += m.dst_device_id.to_bytes(1, "little")
        msg_data += m.src_device_id.to_bytes(1, "little")
        msg_data += m.payload

        checksum = sum(msg_data) & 0xFFFF
        msg_data += bytearray(struct.pack(pingmessage.PingMessage.endianess + pingmessage.PingMessage.checksum_format, checksum))

        m.msg_data = msg_data 
        m.checksum = checksum

        return m

    # Enable logging 
    def start_logging(self, new_log = False, log_directory = None):
        if self.logging:
            return

        self.logging = True

        if self.current_log is None or new_log:
            self.new_log(log_directory)
    
    def stop_logging(self):
        self.logging = False

    # Creates a new log file
    def new_log(self, log_directory=None):
        dt = datetime.now()
        save_name = dt.strftime("%Y-%m-%d-%H-%M")
        
        if log_directory is None:
            project_root = Path.cwd().parent
            self.log_directory = project_root / "logs/s500"
        else:
            self.log_directory = Path(log_directory)

        self.log_directory.mkdir(parents=True, exist_ok=True)

        log_path = self.log_directory / f"{save_name}.svlog"

        if log_path.exists():
            log_path.unlink() # delete existing file (program was restarted quickly)
            
        self.current_log = log_path
        self.logging = True
        self.bytes_written = 0

        print(f"Logging to {self.current_log}")

        self.write_data(self.build_metadata_packet())

    # Write data to .svlog file
    def write_data(self, msg):
        if not self.logging or not self.current_log:
            return
        
        try:
            if self.bytes_written > MAX_LOG_SIZE_MB * 1000000:
                self.new_log(log_directory=self.log_directory)

            with open(self.current_log, 'ab') as f:
                f.write(msg.msg_data)
                self.bytes_written += len(msg.msg_data)

        except (OSError, IOError) as e:
            print(f"[LOGGING ERROR] Failed to write to log file {self.current_log}: {e}")
            self.stop_logging()

        except Exception as e:
            print(f"[LOGGING ERROR] Unexpected error: {e}")
            self.stop_logging()

    # Override wait_message to format power results before returning
    def wait_message(self, message_ids, timeout=0.5):
        tstart = time.time()
        while time.time() < tstart + timeout:
            msg = self.read()
            if msg is not None:
                if (msg.message_id == definitions.S500_PROFILE6_T):
                        power_byte_array = bytearray(msg.pwr_results)
                        power_results = struct.unpack('<' + 'H' * int(msg.num_results), power_byte_array)
                        msg.pwr_results = power_results

                if msg.message_id in message_ids:
                    if self.logging:
                        self.write_data(msg)
                    return msg
            time.sleep(0.005)
        return None

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 192.168.2.2:9092")
    parser.add_argument('--tcp', action="store", required=False, type=str, help="Sounder IP:Port. E.g: 192.168.2.86:51200")
    args = parser.parse_args()
    if args.device is None and args.udp is None and args.tcp is None:
        parser.print_help()
        exit(1)

    p = S500()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))
    elif args.tcp is not None:
        (host, port) = args.tcp.split(':')
        p.connect_tcp(host, int(port))

    print("Initialized: %s" % p.initialize())
    if p.iodev:
        try:
            p.iodev.close()
        except Exception as e:
            print(f"Failed to close socket: {e}")