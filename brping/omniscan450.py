#!/usr/bin/env python3

# omniscan450.py
# A device API for the Cerulean Sonar Omniscan 450 sonar

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from brping import definitions
from brping import PingDevice
from brping import pingmessage
import time
import math
import struct
import socket
from datetime import datetime, timezone
from pathlib import Path

# Imports for svlog header
import json
import os
import sys
import platform

MAX_LOG_SIZE_MB = 500

class Omniscan450(PingDevice):
    def __init__(self, logging = False, log_directory = None):
        super().__init__()
        self.logging = logging
        self.log_directory = log_directory
        self.bytes_written = None
        self.current_log = None
        
    def initialize(self):
        if (self.readDeviceInformation() is None):
            return False
        if self.logging:
            self.new_log(self.log_directory)
        return True

    ##
    # @brief Get a os_mono_profile message from the device\n
    # Message description:\n
    # A profile produced from a single acoustic measurement. The data returned is an array of response strength, in dB, at even intervals across the scan region. The scan region is defined as the region between <scan_start> and <scan_start + scan_length> millimeters away from the transducer. Note that the amplitude of the results are in dB. This is just to keep high dynamic range in the u16 sized data elements. Normally these are converted back to linear power or signal levels.
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # ping_number: sequentially assigned from 0 at power up\n
    # start_mm: Units: mm; The beginning of the scan region in mm from the transducer.\n
    # length_mm: Units: mm; The length of the scan region.\n
    # timestamp_ms: Units: ms; msec since power up at time of ping\n
    # ping_hz: Units: hz; Frequency of acoustic signal\n
    # gain_index: 0-7\n
    # num_results: length of pwr_results array\n
    # sos_dmps: speed of sound, decimeters/sec\n
    # channel_number: \n
    # reserved: \n
    # pulse_duration_sec: \n
    # analog_gain: \n
    # max_pwr_db: \n
    # min_pwr_db: \n
    # transducer_heading_deg: \n
    # vehicle_heading_deg: \n
    # pwr_results: An array of return strength measurements taken at regular intervals across the scan region. The first element is the closest measurement to the sensor, and the last element is the farthest measurement in the scanned range. power results scaled from min_pwr_db to max_pwr_db\n
    def get_os_mono_profile(self):
        if self.request(definitions.OMNISCAN450_OS_MONO_PROFILE) is None:
            return None
        data = ({
            "ping_number": self._ping_number,  # sequentially assigned from 0 at power up
            "start_mm": self._start_mm,  # Units: mm; The beginning of the scan region in mm from the transducer.
            "length_mm": self._length_mm,  # Units: mm; The length of the scan region.
            "timestamp_ms": self._timestamp_ms,  # Units: ms; msec since power up at time of ping
            "ping_hz": self._ping_hz,  # Units: hz; Frequency of acoustic signal
            "gain_index": self._gain_index,  # 0-7
            "num_results": self._num_results,  # length of pwr_results array
            "sos_dmps": self._sos_dmps,  # speed of sound, decimeters/sec
            "channel_number": self._channel_number,  # 
            "reserved": self._reserved,  # 
            "pulse_duration_sec": self._pulse_duration_sec,  # 
            "analog_gain": self._analog_gain,  # 
            "max_pwr_db": self._max_pwr_db,  # 
            "min_pwr_db": self._min_pwr_db,  # 
            "transducer_heading_deg": self._transducer_heading_deg,  # 
            "vehicle_heading_deg": self._vehicle_heading_deg,  # 
            "pwr_results": self._pwr_results,  # An array of return strength measurements taken at regular intervals across the scan region. The first element is the closest measurement to the sensor, and the last element is the farthest measurement in the scanned range. power results scaled from min_pwr_db to max_pwr_db
        })
        return data


    def control_os_ping_params(self, start_mm, length_mm, msec_per_ping, reserved_1, reserved_2, pulse_len_percent, filter_duration_percent, gain_index, num_results, enable, reserved_3):
        m = pingmessage.PingMessage(definitions.OMNISCAN450_OS_PING_PARAMS)
        m.start_mm = start_mm
        m.length_mm = length_mm
        m.msec_per_ping = msec_per_ping
        m.reserved_1 = reserved_1
        m.reserved_2 = reserved_2
        m.pulse_len_percent = pulse_len_percent
        m.filter_duration_percent = filter_duration_percent
        m.gain_index = gain_index
        m.num_results = num_results
        m.enable = enable
        m.reserved_3 = reserved_3
        m.pack_msg_data()
        self.write(m.msg_data)

    def control_set_speed_of_sound(self, speed_of_sound):
        m = pingmessage.PingMessage(definitions.OMNISCAN450_SET_SPEED_OF_SOUND)
        m.speed_of_sound = speed_of_sound
        m.pack_msg_data()
        self.write(m.msg_data)


    def readDeviceInformation(self):
        return self.request(definitions.COMMON_DEVICE_INFORMATION)

    # Calculate the milliseconds per ping from a ping rate
    @staticmethod
    def calc_msec_per_ping(ping_rate):
        return math.floor(1000.0 / ping_rate)

    # Calculate pulse length percent from percent value
    @staticmethod
    def calc_pulse_length_pc(percent):
        if percent > 0:
            return 0.01 * percent
        else:
            return 1.5 / 1200

    # Converts power results to correct format
    @staticmethod
    def scale_power(msg):
        scaled_power_results = []
        for i in range(len(msg.pwr_results)):
            scaled_power_results.append(msg.min_pwr_db + (msg.pwr_results[i] / 65535.0) * (msg.max_pwr_db - msg.min_pwr_db))
        final_power_results = tuple(scaled_power_results)
        return final_power_results

    # Reads a single packet from a file
    @staticmethod
    def read_packet(file):
        sync = file.read(2)
        if sync != b'BR':
            return None
        
        payload_len_bytes = file.read(2)
        if len(payload_len_bytes) < 2:
            return None
        payload_len = int.from_bytes(payload_len_bytes, 'little')

        msg_id = file.read(2)
        if len(msg_id) < 2:
            return None

        remaining = 2 + payload_len + 2
        rest = file.read(remaining)
        if len(rest) < remaining:
            return None

        msg_bytes = sync + payload_len_bytes + msg_id + rest
        return pingmessage.PingMessage(msg_data=msg_bytes)

    # Builds the packet containing metadata for the beginning of .svlog
    def build_metadata_packet(self):
        protocol = "tcp" # default fallback
        if self.iodev:
            if self.iodev.type == socket.SOCK_STREAM:
                protocol = "tcp"
            elif self.iodev.type == socket.SOCK_DGRAM:
                protocol = "udp"
        
        if self.server_address:
            url = f"{protocol}://{self.server_address[0]}:{self.server_address[1]}"
        else:
            url = f"{protocol}://unknown"

        content = {
            "session_id": 1,
            "session_uptime": 0.0,
            "session_devices": [
                {
                    "url": url,
                    "product_id": "os450"
                }
            ],
            "session_platform": None,
            "session_clients": [],
            "session_plan_name": None,

            "is_recording": True,
            "sonarlink_version": "",
            "os_hostname": platform.node(),
            "os_uptime": None,
            "os_version": platform.version(),
            "os_platform": platform.system().lower(),
            "os_release": platform.release(),

            "process_path": sys.executable,
            "process_version": f"v{platform.python_version()}",
            "process_uptime": time.process_time(),
            "process_arch": platform.machine(),

            "timestamp": datetime.now(timezone.utc).isoformat(),
            "timestamp_timezone_offset": datetime.now().astimezone().utcoffset().total_seconds() // 60
        }

        json_bytes = json.dumps(content, indent=2).encode("utf-8")

        m = pingmessage.PingMessage(definitions.OMNISCAN450_JSON_WRAPPER)
        m.payload = json_bytes
        m.payload_length = len(json_bytes)

        msg_data = bytearray()
        msg_data += b"BR"
        msg_data += m.payload_length.to_bytes(2, "little")
        msg_data += m.message_id.to_bytes(2, "little")
        msg_data += m.dst_device_id.to_bytes(1, "little")
        msg_data += m.src_device_id.to_bytes(1, "little")
        msg_data += m.payload

        checksum = sum(msg_data) & 0xFFFF
        msg_data += bytearray(struct.pack(pingmessage.PingMessage.endianess + pingmessage.PingMessage.checksum_format, checksum))

        m.msg_data = msg_data 
        m.checksum = checksum

        return m
    
    # Enable logging 
    def start_logging(self, new_log = False, log_directory = None):
        if self.logging:
            return

        self.logging = True

        if self.current_log is None or new_log:
            self.new_log(log_directory)

    # Disable logging
    def stop_logging(self):
        self.logging = False

    # Creates a new log file
    def new_log(self, log_directory=None):
        dt = datetime.now()
        save_name = dt.strftime("%Y-%m-%d-%H-%M")
        
        if log_directory is None:
            project_root = Path.cwd().parent
            self.log_directory = project_root / "logs/omniscan"
        else:
            self.log_directory = Path(log_directory)

        self.log_directory.mkdir(parents=True, exist_ok=True)

        log_path = self.log_directory / f"{save_name}.svlog"

        if log_path.exists():
            log_path.unlink() # delete existing file (program was restarted quickly)
            
        self.current_log = log_path
        self.logging = True
        self.bytes_written = 0

        print(f"Logging to {self.current_log}")

        self.write_data(self.build_metadata_packet())

    # Write data to .svlog file
    def write_data(self, msg):
        if not self.logging or not self.current_log:
            return
        
        try:
            if self.bytes_written > MAX_LOG_SIZE_MB * 1000000:
                self.new_log(log_directory=self.log_directory)

            with open(self.current_log, 'ab') as f:
                f.write(msg.msg_data)
                self.bytes_written += len(msg.msg_data)

        except (OSError, IOError) as e:
            print(f"[LOGGING ERROR] Failed to write to log file {self.current_log}: {e}")
            self.stop_logging()

        except Exception as e:
            print(f"[LOGGING ERROR] Unexpected error: {e}")
            self.stop_logging()

    # Override wait_message to format power results before returning
    def wait_message(self, message_ids, timeout=0.5):
        tstart = time.time()
        while time.time() < tstart + timeout:
            msg = self.read()
            if msg is not None:
                if msg.message_id == definitions.OMNISCAN450_OS_MONO_PROFILE:
                    power_byte_array = bytearray(msg.pwr_results)
                    power_results = struct.unpack('<' + 'H' * int(msg.num_results), power_byte_array)
                    msg.pwr_results = power_results

                if msg.message_id in message_ids:
                    if self.logging:
                        self.write_data(msg)
                    return msg
            time.sleep(0.005)
        return None

    ##
    # @brief Do the connection via an TCP link
    #
    # @param host: TCP server address (IPV4) or name
    # @param port: port used to connect with server
    #
    def connect_tcp(self, host: str = None, port: int = 12345):
        if host is None:
            host = '0.0.0.0'
        
        self.server_address = (host, port)
        try:
            print("Opening %s:%d" % self.server_address)
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.iodev.connect(self.server_address)
            self.iodev.setblocking(0)
        
        except Exception as exception:
            raise Exception("Failed to open the given TCP port: {0}".format(exception))

    ##
    # @brief Read available data from the io device
    def read_io(self):
        if self.iodev == None:
            raise Exception("IO device is null, please configure a connection before using the class.")
        elif type(self.iodev).__name__ == 'Serial':
            bytes = self.iodev.read(self.iodev.in_waiting)
            self._input_buffer.extendleft(bytes)
        else: # Socket
            buffer_size = 4096
            while True:
                try: # Check if we are reading before closing a connection
                    bytes = self.iodev.recv(buffer_size)

                    if not bytes:
                        # if recv() returns empty, connection is closed (TCP)
                        if self.iodev.type == socket.SOCK_STREAM:
                            raise ConnectionError("TCP connection closed by peer.")

                    self._input_buffer.extendleft(bytes)

                    if len(bytes) < buffer_size:
                        break

                except BlockingIOError as exception:
                    pass # Ignore exceptions related to read before connection, a result of UDP nature
                
                except ConnectionResetError as e:
                    raise ConnectionError("Socket connection was reset: %s" % str(e))

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 192.168.2.2:9092")
    parser.add_argument('--tcp', action="store", required=False, type=str, help="Omniscan IP:Port. E.g: 192.168.2.92:51200")
    args = parser.parse_args()
    if args.device is None and args.udp is None and args.tcp is None:
        parser.print_help()
        exit(1)

    p = Omniscan450()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))
    elif args.tcp is not None:
        (host, port) = args.tcp.split(':')
        p.connect_tcp(host, int(port))

    print("Initialized: %s" % p.initialize())

    if p.iodev:
        try:
            p.iodev.close()
        except Exception as e:
            print(f"Failed to close socket: {e}")