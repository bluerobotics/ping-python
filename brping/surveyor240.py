#!/usr/bin/env python3

# surveyor240.py
# A device API for the Cerulean Sonar Surveyor240 scanning sonar

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from brping import definitions
from brping import PingDevice
from brping import pingmessage
import math
import time
import struct
import socket
from datetime import datetime, timezone
from pathlib import Path

# Imports for svlog header
import json
import os
import sys
import platform

MAX_LOG_SIZE_MB = 500

class Surveyor240(PingDevice):
    def __init__(self, logging = False, log_directory = None):
        super().__init__()
        self.logging = logging
        self.log_directory = log_directory
        self.bytes_written = None
        self.current_log = None

    def initialize(self):
        if (self.readDeviceInformation() is None):
            return False
        if self.logging:
            self.new_log(self.log_directory)
        return True

    ##
    # @brief Get a atof_point_data message from the device\n
    # Message description:\n
    # A response packet Surveyor sends to the host application containing angle and time of flight for each detected point.
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # pwr_up_msec: Units: msec; Time at start of ping, msec since power on.\n
    # utc_msec: Units: msec; Time at start of ping, utc msec (1970 epoc). Will be 0 if not avaliable.\n
    # listening_sec: Units: sec; Time from start of ping to last range bin.\n
    # sos_mps: Units: float; Speed of sound (mps) used in angle calculations.\n
    # ping_number: Assigned sequentially from power on.\n
    # ping_hz: Units: Hz; Frequency of the ping signal (Hz).\n
    # pulse_sec: Units: sec; Pulse length in seconds.\n
    # flags: reserved\n
    # num_points: Number of points reported in the points field\n
    # reserved: \n
    # atof_point_data: \n
    def get_atof_point_data(self):
        if self.request(definitions.SURVEYOR240_ATOF_POINT_DATA) is None:
            return None
        data = ({
            "pwr_up_msec": self._pwr_up_msec,  # Units: msec; Time at start of ping, msec since power on.
            "utc_msec": self._utc_msec,  # Units: msec; Time at start of ping, utc msec (1970 epoc). Will be 0 if not avaliable.
            "listening_sec": self._listening_sec,  # Units: sec; Time from start of ping to last range bin.
            "sos_mps": self._sos_mps,  # Units: float; Speed of sound (mps) used in angle calculations.
            "ping_number": self._ping_number,  # Assigned sequentially from power on.
            "ping_hz": self._ping_hz,  # Units: Hz; Frequency of the ping signal (Hz).
            "pulse_sec": self._pulse_sec,  # Units: sec; Pulse length in seconds.
            "flags": self._flags,  # reserved
            "num_points": self._num_points,  # Number of points reported in the points field
            "reserved": self._reserved,  # 
            "atof_point_data": self._atof_point_data,  # 
        })
        return data

    ##
    # @brief Get a attitude_report message from the device\n
    # Message description:\n
    # A response packet Surveyor sends to the host application containing information about the attitude (pitch and roll) of the device based on it's internal sensors.
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # up_vec_x: World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)\n
    # up_vec_y: World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)\n
    # up_vec_z: World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)\n
    # reserved_1: reserved for future magnetic field vector\n
    # reserved_2: reserved for future magnetic field vector\n
    # reserved_3: reserved for future magnetic field vector\n
    # utc_msec: Units: msec; utc msec (1970 epoc). Will be 0 if not avaliable\n
    # pwr_up_msec: Units: msec; msec since power up\n
    def get_attitude_report(self):
        if self.request(definitions.SURVEYOR240_ATTITUDE_REPORT) is None:
            return None
        data = ({
            "up_vec_x": self._up_vec_x,  # World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)
            "up_vec_y": self._up_vec_y,  # World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)
            "up_vec_z": self._up_vec_z,  # World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)
            "reserved_1": self._reserved_1,  # reserved for future magnetic field vector
            "reserved_2": self._reserved_2,  # reserved for future magnetic field vector
            "reserved_3": self._reserved_3,  # reserved for future magnetic field vector
            "utc_msec": self._utc_msec,  # Units: msec; utc msec (1970 epoc). Will be 0 if not avaliable
            "pwr_up_msec": self._pwr_up_msec,  # Units: msec; msec since power up
        })
        return data

    ##
    # @brief Get a water_stats message from the device\n
    # Message description:\n
    # A response packet Surveyor sends to the host application containing information about the temperature and pressure of the water.
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # temperature: Units: deg C; \n
    # pressure: Units: Bar; \n
    def get_water_stats(self):
        if self.request(definitions.SURVEYOR240_WATER_STATS) is None:
            return None
        data = ({
            "temperature": self._temperature,  # Units: deg C; 
            "pressure": self._pressure,  # Units: Bar; 
        })
        return data

    ##
    # @brief Get a yz_point_data message from the device\n
    # Message description:\n
    # A response packet that Surveyor sends to the host application containing the detected depth points.
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
    # timestamp_msec: Units: msec; msec since power up\n
    # ping_number: Assigned sequentially from power on.\n
    # sos_mps: Units: m/s; Speed of sound\n
    # up_vec_x: World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)\n
    # up_vec_y: World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)\n
    # up_vec_z: World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)\n
    # mag_vec_x: reserved for future magnetic field vector\n
    # mag_vec_y: reserved for future magnetic field vector\n
    # mag_vec_z: reserved for future magnetic field vector\n
    # reserved_0: \n
    # reserved_1: \n
    # reserved_2: \n
    # reserved_3: \n
    # reserved_4: \n
    # reserved_5: \n
    # reserved_6: \n
    # reserved_7: \n
    # reserved_8: \n
    # reserved_9: \n
    # water_degC: Units: deg C; -1000 if sensor not installed\n
    # water_bar: Units: bar; Water pressure in bar. -1000 if sensor not installed\n
    # heave_m: Units: meters; Reserved for heave in meters.\n
    # start_m: Units: meters; Range at the beginning of the analyzed signals for this ping.\n
    # end_m: Units: meters; Range at the end of the analyzed signals for this ping.\n
    # unused: \n
    # num_points: Number of points reported in the points field\n
    # yz_point_data: Y and Z value pairs for each detected point. Y is athwartships offset in meters, positive to the port side. Z is depth, positive up so all z values will be negative.\n
    def get_yz_point_data(self):
        if self.request(definitions.SURVEYOR240_YZ_POINT_DATA) is None:
            return None
        data = ({
            "timestamp_msec": self._timestamp_msec,  # Units: msec; msec since power up
            "ping_number": self._ping_number,  # Assigned sequentially from power on.
            "sos_mps": self._sos_mps,  # Units: m/s; Speed of sound
            "up_vec_x": self._up_vec_x,  # World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)
            "up_vec_y": self._up_vec_y,  # World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)
            "up_vec_z": self._up_vec_z,  # World up vector (x, y, z) in the device coordinate system (x forward, y port, z up)
            "mag_vec_x": self._mag_vec_x,  # reserved for future magnetic field vector
            "mag_vec_y": self._mag_vec_y,  # reserved for future magnetic field vector
            "mag_vec_z": self._mag_vec_z,  # reserved for future magnetic field vector
            "reserved_0": self._reserved_0,  # 
            "reserved_1": self._reserved_1,  # 
            "reserved_2": self._reserved_2,  # 
            "reserved_3": self._reserved_3,  # 
            "reserved_4": self._reserved_4,  # 
            "reserved_5": self._reserved_5,  # 
            "reserved_6": self._reserved_6,  # 
            "reserved_7": self._reserved_7,  # 
            "reserved_8": self._reserved_8,  # 
            "reserved_9": self._reserved_9,  # 
            "water_degC": self._water_degC,  # Units: deg C; -1000 if sensor not installed
            "water_bar": self._water_bar,  # Units: bar; Water pressure in bar. -1000 if sensor not installed
            "heave_m": self._heave_m,  # Units: meters; Reserved for heave in meters.
            "start_m": self._start_m,  # Units: meters; Range at the beginning of the analyzed signals for this ping.
            "end_m": self._end_m,  # Units: meters; Range at the end of the analyzed signals for this ping.
            "unused": self._unused,  # 
            "num_points": self._num_points,  # Number of points reported in the points field
            "yz_point_data": self._yz_point_data,  # Y and Z value pairs for each detected point. Y is athwartships offset in meters, positive to the port side. Z is depth, positive up so all z values will be negative.
        })
        return data


    def control_set_net_info(self, ntp_ip_address, subnet_mask, gateway_ip):
        m = pingmessage.PingMessage(definitions.SURVEYOR240_SET_NET_INFO)
        m.ntp_ip_address = ntp_ip_address
        m.subnet_mask = subnet_mask
        m.gateway_ip = gateway_ip
        m.pack_msg_data()
        self.write(m.msg_data)

    def control_set_ping_parameters(self, start_mm=0, end_mm=5000, sos_mps=1500, gain_index=-1, msec_per_ping=100, deprecated=0, diagnostic_injected_signal=0, ping_enable=False, enable_channel_data=False, reserved_for_raw_data=False, enable_yz_point_data=False, enable_atof_data=False, target_ping_hz=240000, n_range_steps=400, reserved=0, pulse_len_steps=1.5):
        m = pingmessage.PingMessage(definitions.SURVEYOR240_SET_PING_PARAMETERS)
        m.start_mm = start_mm
        m.end_mm = end_mm
        m.sos_mps = sos_mps
        m.gain_index = gain_index
        m.msec_per_ping = msec_per_ping
        m.deprecated = deprecated
        m.diagnostic_injected_signal = diagnostic_injected_signal
        m.ping_enable = ping_enable
        m.enable_channel_data = enable_channel_data
        m.reserved_for_raw_data = reserved_for_raw_data
        m.enable_yz_point_data = enable_yz_point_data
        m.enable_atof_data = enable_atof_data
        m.target_ping_hz = target_ping_hz
        m.n_range_steps = n_range_steps
        m.reserved = reserved
        m.pulse_len_steps = pulse_len_steps
        m.pack_msg_data()
        self.write(m.msg_data)

    def control_utc_response(self, utc_msec, accuracy_msec):
        m = pingmessage.PingMessage(definitions.SURVEYOR240_UTC_RESPONSE)
        m.utc_msec = utc_msec
        m.accuracy_msec = accuracy_msec
        m.pack_msg_data()
        self.write(m.msg_data)


    def readDeviceInformation(self):
        return self.request(definitions.COMMON_DEVICE_INFORMATION)

    # Calculate the milliseconds per ping from a ping rate
    @staticmethod
    def calc_msec_per_ping(ping_rate):
        return math.floor(1000.0 / ping_rate)

    def get_utc_time(self):
        clock_offset = 0
        round_trip_delay = 5000

        local_now = datetime.now(timezone.utc)
        corrected_time = local_now.timestamp() * 1000 + clock_offset / 2
        accuracy = round_trip_delay / 2

        utc_msec_u64 = int(corrected_time) & 0xFFFFFFFFFFFFFFFF
        accuracy_msec = int(accuracy) & 0xFFFFFFFF

        return utc_msec_u64, accuracy_msec

    # Reads a single packet from a file
    @staticmethod
    def read_packet(file):
        sync = file.read(2)
        if sync != b'BR':
            return None
        
        payload_len_bytes = file.read(2)
        if len(payload_len_bytes) < 2:
            return None
        payload_len = int.from_bytes(payload_len_bytes, 'little')

        msg_id = file.read(2)
        if len(msg_id) < 2:
            return None

        remaining = 2 + payload_len + 2
        rest = file.read(remaining)
        if len(rest) < remaining:
            return None

        msg_bytes = sync + payload_len_bytes + msg_id + rest
        return pingmessage.PingMessage(msg_data=msg_bytes)

    # Builds the packet containing metadata for the beginning of .svlog
    def build_metadata_packet(self):
        protocol = "tcp" # default fallback
        if self.iodev:
            if self.iodev.type == socket.SOCK_STREAM:
                protocol = "tcp"
            elif self.iodev.type == socket.SOCK_DGRAM:
                protocol = "udp"
        
        if self.server_address:
            url = f"{protocol}://{self.server_address[0]}:{self.server_address[1]}"
        else:
            url = f"{protocol}://unknown"

        content = {
            "session_id": 1,
            "session_uptime": 0.0,
            "session_devices": [
                {
                    "url": url,
                    "product_id": "mbes24016"
                }
            ],
            "session_platform": None,
            "session_clients": [],
            "session_plan_name": None,

            "is_recording": True,
            "sonarlink_version": "",
            "os_hostname": platform.node(),
            "os_uptime": None,
            "os_version": platform.version(),
            "os_platform": platform.system().lower(),
            "os_release": platform.release(),

            "process_path": sys.executable,
            "process_version": f"v{platform.python_version()}",
            "process_uptime": time.process_time(),
            "process_arch": platform.machine(),

            "timestamp": datetime.now(timezone.utc).isoformat(),
            "timestamp_timezone_offset": datetime.now().astimezone().utcoffset().total_seconds() // 60
        }

        json_bytes = json.dumps(content, indent=2).encode("utf-8")

        m = pingmessage.PingMessage(definitions.OMNISCAN450_JSON_WRAPPER)
        m.payload = json_bytes
        m.payload_length = len(json_bytes)

        msg_data = bytearray()
        msg_data += b"BR"
        msg_data += m.payload_length.to_bytes(2, "little")
        msg_data += m.message_id.to_bytes(2, "little")
        msg_data += m.dst_device_id.to_bytes(1, "little")
        msg_data += m.src_device_id.to_bytes(1, "little")
        msg_data += m.payload

        checksum = sum(msg_data) & 0xFFFF
        msg_data += bytearray(struct.pack(pingmessage.PingMessage.endianess + pingmessage.PingMessage.checksum_format, checksum))

        m.msg_data = msg_data 
        m.checksum = checksum

        return m

    # Enable logging 
    def start_logging(self, new_log = False, log_directory = None):
        if self.logging:
            return

        self.logging = True

        if self.current_log is None or new_log:
            self.new_log(log_directory)
    
    def stop_logging(self):
        self.logging = False

    # Creates a new log file
    def new_log(self, log_directory=None):
        dt = datetime.now()
        save_name = dt.strftime("%Y-%m-%d-%H-%M")
        
        if log_directory is None:
            project_root = Path.cwd().parent
            self.log_directory = project_root / "logs/surveyor"
        else:
            self.log_directory = Path(log_directory)

        self.log_directory.mkdir(parents=True, exist_ok=True)

        log_path = self.log_directory / f"{save_name}.svlog"

        if log_path.exists():
            log_path.unlink() # delete existing file (program was restarted quickly)
            
        self.current_log = log_path
        self.logging = True
        self.bytes_written = 0

        print(f"Logging to {self.current_log}")

        self.write_data(self.build_metadata_packet())

    # Write data to .svlog file
    def write_data(self, msg):
        if not self.logging or not self.current_log:
            return
        
        try:
            if self.bytes_written > MAX_LOG_SIZE_MB * 1000000:
                self.new_log(log_directory=self.log_directory)

            with open(self.current_log, 'ab') as f:
                f.write(msg.msg_data)
                self.bytes_written += len(msg.msg_data)

        except (OSError, IOError) as e:
            print(f"[LOGGING ERROR] Failed to write to log file {self.current_log}: {e}")
            self.stop_logging()

        except Exception as e:
            print(f"[LOGGING ERROR] Unexpected error: {e}")
            self.stop_logging()

    # Override handle_message to respond to a UTC request from Surveyor
    def handle_message(self, msg):
        if msg.message_id == definitions.SURVEYOR240_UTC_REQUEST:
            now, accuracy = self.get_utc_time()

            response = pingmessage.PingMessage(definitions.SURVEYOR240_UTC_RESPONSE)
            response.utc_msec = now
            response.accuracy_msec = accuracy
            response.pack_msg_data()
            self.write(response.msg_data)

            return True
        
        return super().handle_message(msg)
            
    # Override wait_message to also handle UTC requests from Surveyor and for creating atof_t data
    def wait_message(self, message_ids, timeout=0.5):
        tstart = time.time()
        while time.time() < tstart + timeout:
            msg = self.read()
            if msg is not None:
                if msg.message_id == definitions.SURVEYOR240_UTC_REQUEST:
                    continue
                
                if msg.message_id == definitions.SURVEYOR240_ATOF_POINT_DATA:
                    atof_byte_array = bytearray(msg.atof_point_data)
                    formatted_atof_array = struct.unpack('<' + 'I' * (4*int(msg.num_points)), atof_byte_array)
                    msg.atof_point_data = formatted_atof_array

                if msg.message_id in message_ids:
                    if self.logging:
                        self.write_data(msg)
                    return msg
            time.sleep(0.005)
        return None

    ##
    # @brief Do the connection via an TCP link
    #
    # @param host: TCP server address (IPV4) or name
    # @param port: port used to connect with server
    #
    def connect_tcp(self, host: str = None, port: int = 12345, timeout: float = 5.0):
        if host is None:
            host = '0.0.0.0'
        
        self.server_address = (host, port)
        try:
            print("Opening %s:%d" % self.server_address)
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.iodev.settimeout(timeout)
            self.iodev.connect(self.server_address)
            self.iodev.setblocking(0)

        except socket.timeout:
            print("Unable to connect to device")
            raise Exception("Connection timed out after {0} seconds".format(timeout))        
        except Exception as exception:
            raise Exception("Failed to open the given TCP port: {0}".format(exception))

    ##
    # @brief Read available data from the io device
    def read_io(self):
        if self.iodev == None:
            raise Exception("IO device is null, please configure a connection before using the class.")
        elif type(self.iodev).__name__ == 'Serial':
            bytes = self.iodev.read(self.iodev.in_waiting)
            self._input_buffer.extendleft(bytes)
        else: # Socket
            buffer_size = 4096
            while True:
                try: # Check if we are reading before closing a connection
                    bytes = self.iodev.recv(buffer_size)

                    if not bytes:
                        # if recv() returns empty, connection is closed (TCP)
                        if self.iodev.type == socket.SOCK_STREAM:
                            raise ConnectionError("TCP connection closed by peer.")

                    self._input_buffer.extendleft(bytes)

                    if len(bytes) < buffer_size:
                        break

                except BlockingIOError as exception:
                    pass # Ignore exceptions related to read before connection, a result of UDP nature
                
                except ConnectionResetError as e:
                    raise ConnectionError("Socket connection was reset: %s" % str(e))       

    # Class to represent the atof_t struct
    class atof_t:
        def __init__(self, angle=0.0, tof=0.0, reserved=(0,0)):
            self.angle = angle
            self.tof = tof
            self.reserved = reserved

        def __repr__(self):
            return f"angle: {self.angle}, tof: {self.tof}"

    # Creates atof_t[] and fills it with structured atof_ts using data from the message
    @staticmethod
    def create_atof_list(msg):
        raw_array = msg.atof_point_data

        atof_list = []
        for i in range(msg.num_points):
            idx = i * 4

            angle = struct.unpack('<f', struct.pack('<I', raw_array[idx]))[0]
            tof = struct.unpack('<f', struct.pack('<I', raw_array[idx + 1]))[0]
            reserved = (raw_array[idx + 2], raw_array[idx + 3])

            atof = Surveyor240.atof_t(angle, tof, reserved)
            atof_list.append(atof)
        
        return tuple(atof_list)

    # Creates yz_point_data and fills it with the correct data from the message
    @staticmethod
    def create_yz_point_data(msg):
        raw_array = msg.yz_point_data

        yz_list = struct.unpack('<' + 'f' * int(msg.num_points) * 2, raw_array)
        return yz_list


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 192.168.2.2:9092")
    parser.add_argument('--tcp', action="store", required=False, type=str, help="Surveyor IP:Port. E.g: 192.168.2.86:62312")
    args = parser.parse_args()
    if args.device is None and args.udp is None and args.tcp is None:
        parser.print_help()
        exit(1)

    p = Surveyor240()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))
    elif args.tcp is not None:
        (host, port) = args.tcp.split(':')
        p.connect_tcp(host, int(port))

    print("Initialized: %s" % p.initialize())
    if p.iodev:
        try:
            p.iodev.close()
        except Exception as e:
            print(f"Failed to close socket: {e}")