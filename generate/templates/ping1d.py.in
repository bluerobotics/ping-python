#!/usr/bin/env python3

"""
A device API for the Blue Robotics Ping1D echosounder.

This module provides a Python API for interacting with the Ping1D echosounder from Blue Robotics. It extends the
PingDevice class to include echosounder-specific functionalities such as distance measurement and sonar pulse configuration.
"""

from brping import definitions
from brping import PingDevice
from brping import pingmessage

class Ping1D(PingDevice):
    """
    Represents a Ping1D Echosounder from Blue Robotics.

    This class provides methods to control and retrieve data from the Ping1D echosounder,
    which includes functionality to measure distances and read from underwater environments.
    """

    def legacyRequest(self, m_id, timeout=0.5):
        msg = pingmessage.PingMessage()
        # legacy hack logic is in PingMessage
        # TODO: remove that logic and construct/assemble an arbitrary PingMessage
        msg.request_id = m_id 
        msg.pack_msg_data()
        self.write(msg.msg_data)

        # uncomment to return nacks in addition to m_id
        # return self.wait_message([m_id, definitions.COMMON_NACK], timeout)

        return self.wait_message([m_id], timeout)

    def initialize(self):
        if not PingDevice.initialize(self):
            return False
        if self.legacyRequest(definitions.PING1D_GENERAL_INFO) is None:
            return False
        return True

{% for msg in messages["get"]|sort %}
    def get_{{msg}}(self):
        """
        Get a {{ msg|replace("get_", "") }} message from the device.\n
        Message description: {{ messages["get"][msg].description }}\n

        :return: None if there is no reply from the device, otherwise a dictionary with the following keys:\n
{% for field in messages["get"][msg].payload %}
            - {{ field.name }}: {{ field.description }}{% if field.units %} (Units: {{ field.units }}){% endif %}\n
{% endfor %}
        :rtype: dict or None
        """
        if self.legacyRequest(definitions.PING1D_{{msg|upper}}) is None:
            return None
        data = ({
{% for field in messages["get"][msg].payload %}
            "{{field.name}}": self._{{field.name}},  # {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
        })
        return data

{% endfor %}
{% for msg in messages["set"]|sort %}
    def {{msg}}(self{% for field in messages["set"][msg].payload %}, {{field.name}}{% endfor %}, verify=True):
        """
        Send a {{msg}} message to the device.\n
        Message description: {{messages["set"][msg].description}}\n
        Send the message to write the device parameters, then read the values back from the device.\n
{% for field in messages["set"][msg].payload %}
        :param {{field.name}}: {{field.description}}{% if field.units %} (Units: {{field.units}}){% endif %}\n
        :type {{field.name}}: type\n
{% endfor %}\n
        :param verify: Specify whether to verify the new parameters by reading them back from the device. Defaults to True.
        :type verify: bool

        :return: True if successful communication with the device (and verification if verify is True), False otherwise.
        :rtype: bool
        """
        m = pingmessage.PingMessage(definitions.PING1D_{{msg|upper}})
{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)
        if self.legacyRequest(definitions.PING1D_{{msg|replace("set_", "")|upper}}) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
{% if messages["set"][msg].payload %}
                and ({% for field in messages["set"][msg].payload %}self._{{field.name}} != {{field.name}}{{ " or " if not loop.last }}{% endfor %})):
{% endif %}
            return False
        return True  # success

{% endfor %}

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 192.168.2.2:9090")
    args = parser.parse_args()
    if args.device is None and args.udp is None:
        parser.print_help()
        exit(1)

    p = Ping1D()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))

    print("Initialized: %s" % p.initialize())

{% for msg in messages["get"]|sort %}
    print("\ntesting get_{{msg}}")
    result = p.get_{{msg}}()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result is not None))

{% endfor %}
    print("\ntesting set_device_id")
    print("  > > pass: %s < <" % p.set_device_id(43))
    print("\ntesting set_mode_auto")
    print("  > > pass: %s < <" % p.set_mode_auto(False))
    print("\ntesting set_range")
    print("  > > pass: %s < <" % p.set_range(1000, 2000))
    print("\ntesting set_speed_of_sound")
    print("  > > pass: %s < <" % p.set_speed_of_sound(1444000))
    print("\ntesting set_ping_interval")
    print("  > > pass: %s < <" % p.set_ping_interval(36))
    print("\ntesting set_gain_setting")
    print("  > > pass: %s < <" % p.set_gain_setting(3))
    print("\ntesting set_ping_enable")
    print("  > > pass: %s < <" % p.set_ping_enable(True))

    print(p)
