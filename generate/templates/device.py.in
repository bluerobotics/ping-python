#!/usr/bin/env python3

"""
A device API for devices implementing Blue Robotics ping-protocol.

This module serves as a base for device APIs that implement the Blue Robotics ping-protocol, facilitating
communication and control of marine robotic devices through serial and network interfaces.
"""

from brping import definitions
from brping import pingmessage
from collections import deque
import serial
import socket
import time

class PingDevice(object):
    """
    Base class for devices using the Blue Robotics ping-protocol.

    Provides common functionalities for serial and network communication with devices that support
    the ping-protocol, offering foundational elements for device-specific implementations.
    """

{% for field in all_fields|sort %}
    _{{field}} = None
{% endfor%}

    _input_buffer = deque()
    def __init__(self):
        ## A helper class to take care of decoding the input stream
        self.parser = pingmessage.PingParser()

        ## device id of this Ping1D object, used for dst_device_id in outgoing messages
        self.my_id = 255

        # IO device
        self.iodev = None
        self.server_address = None

    def connect_serial(self, device_name: str, baudrate: int =115200):
        """Do the connection via an serial link

        :param device_name: Serial device name. E.g: /dev/ttyUSB0 or COM5
        :type device_name: str
        :param baudrate: Connection baudrate used in the serial communication, defaults to 115200
        :type baudrate: int
        :raises Exception: Failed to open the given serial port
        """
        if device_name is None:
            print("Device name is required")
            return

        try:
            print("Opening %s at %d bps" % (device_name, baudrate))

            ## Serial object for device communication
            # write_timeout fixes it getting stuck forever atempting to write to
            # /dev/ttyAMA0 on Raspberry Pis, this raises an exception instead.
            self.iodev = serial.Serial(device_name, baudrate, write_timeout=1.0)
            self.iodev.send_break()
            time.sleep(0.001)
            self.iodev.write("U".encode("ascii"))

        except Exception as exception:
            raise Exception("Failed to open the given serial port: {0}".format(exception))

    def connect_udp(self, host: str = None, port: int = 12345):
        """Do the connection via an UDP link.

        :param host: UDP server address (IPv4) or name. Defaults to None.
        :type host: str
        :param port: Port used to connect with the server. Defaults to 12345.
        :type port: int
        """
        if host is None:
            host = '0.0.0.0' # Connect to local host

        self.server_address = (host, port)
        try:
            print("Opening %s:%d" % self.server_address)
            ## Serial object for device communication
            self.iodev = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.iodev.connect(self.server_address)
            self.iodev.setblocking(0)

        except Exception as exception:
            raise Exception("Failed to open the given UDP port: {0}".format(exception))

    def read_io(self):
        """Read available data from the io device"""
        if self.iodev == None:
            raise Exception("IO device is null, please configure a connection before using the class.")
        elif type(self.iodev).__name__ == 'Serial':
            bytes = self.iodev.read(self.iodev.in_waiting)
            self._input_buffer.extendleft(bytes)
        else: # Socket
            udp_buffer_size = 4096
            try: # Check if we are reading before closing a connection
                bytes = self.iodev.recv(udp_buffer_size)
                self._input_buffer.extendleft(bytes)
                if len(bytes) == udp_buffer_size:
                    self.update_input_buffer()
            except BlockingIOError as exception:
                pass # Ignore exceptions related to read before connection, a result of UDP nature

    def read(self):
        """
        Consume rx buffer data until a new message is successfully decoded.

        :return: A new PingMessage as soon as a message is parsed, or None if the buffer is empty and no message has been parsed.
                There may be data remaining in the buffer to be parsed, thus requiring subsequent calls to this method.
        :rtype: PingMessage or None
        """
        self.read_io()
        while len(self._input_buffer):
            b = self._input_buffer.pop()

            if self.parser.parse_byte(b) == pingmessage.PingParser.NEW_MESSAGE:
                # a successful read depends on a successful handling
                if not self.handle_message(self.parser.rx_msg):
                    return None
                else:
                    return self.parser.rx_msg
        return None

    def write(self, data):
        """
        Write data to device.

        :param data: Bytearray to write to the device.
        :type data: bytearray
        :return: Number of bytes written.
        :rtype: int
        """
        if self.iodev == None:
            raise Exception("IO device is null, please configure a connection before using the class.")
        elif type(self.iodev).__name__ == 'Serial':
            return self.iodev.write(data)
        else: # Socket
            return self.iodev.send(data)

    def initialize(self):
        """
        Make sure there is a device on and read some initial data.

        :return: True if the device replies with expected data, False otherwise.
        :rtype: bool
        """
        return self.request(definitions.COMMON_PROTOCOL_VERSION) is not None

    def request(self, m_id, timeout=0.5):
        """
        Request the given message ID.

        :param m_id: The message ID to request from the device.
        :type m_id: int
        :param timeout: The time in seconds to wait for the device to send the requested message before timing out. Defaults to 0.5 seconds.
        :type timeout: float
        :return: The device reply if it is received within the timeout period, None otherwise.
        :rtype: PingMessage or None
        """
        msg = pingmessage.PingMessage(definitions.COMMON_GENERAL_REQUEST)
        msg.requested_id = m_id
        msg.pack_msg_data()
        self.write(msg.msg_data)

        # uncomment to return nacks in addition to m_id
        # return self.wait_message([m_id, definitions.COMMON_NACK], timeout)

        return self.wait_message([m_id], timeout)

    def wait_message(self, message_id, timeout=0.5):
        """
        Wait until we receive a message from the device with the desired message_id for timeout seconds.

        :param message_id: The message id to wait to receive from the device.
        :type message_id: int
        :param timeout: The timeout period in seconds to wait. Defaults to 0.5 seconds.
        :type timeout: float
        :return: The message from the device if it is received within the timeout period, None otherwise.
        :rtype: PingMessage or None
        """
        tstart = time.time()
        while time.time() < tstart + timeout:
            msg = self.read()
            if msg is not None:
                if msg.message_id in message_ids:
                    return msg
            time.sleep(0.005)
        return None

    def handle_message(self, msg):
        """
        Handle an incoming message from the device.
        Extract message fields into self attributes.

        :param msg: The PingMessage to handle.
        :type msg: PingMessage
        :return: True if the PingMessage was handled successfully.
        :rtype: bool
        """
        # TODO is this message for us?
        setattr(self, "_src_device_id", msg.src_device_id)
        setattr(self, "_dst_device_id", msg.dst_device_id)

        if msg.message_id in pingmessage.payload_dict:
            try:
                for attr in pingmessage.payload_dict[msg.message_id]["field_names"]:
                    setattr(self, "_" + attr, getattr(msg, attr))
            except AttributeError as e:
                print("attribute error while handling msg %d (%s): %s" % (msg.message_id, msg.name, msg.msg_data))
                return False
        else:
            print("Unrecognized message: %d", msg)
            return False

        return True

    def __repr__(self):
        """
        Dump object into string representation.

        :return: A string representation of the object.
        :rtype: str
        """
        representation = "---------------------------------------------------------\n~Ping Object~"

        attrs = vars(self)
        for attr in sorted(attrs):
            try:
                if attr != 'iodev':
                    representation += "\n  - " + attr + "(hex): " + str([hex(item) for item in getattr(self, attr)])
                if attr != 'data':
                    representation += "\n  - " + attr + "(string): " + str(getattr(self, attr))
            # TODO: Better filter this exception
            except:
                representation += "\n  - " + attr + ": " + str(getattr(self, attr))
        return representation

{% for msg in messages["get"]|sort %}
    def get_{{msg}}(self):
        """
        Get a {{msg|replace("get_", "")}} message from the device\n
        Message description:\n
            {{messages["get"][msg].description}}\n

        :return: None if there is no reply from the device, otherwise a dictionary with the following keys:\n
        {% for field in messages["get"][msg].payload %}
            - {{field.name}}: {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}\n
        {% endfor%}\n
        """
        if self.request(definitions.COMMON_{{msg|upper}}) is None:
            return None
        data = ({
{% for field in messages["get"][msg].payload %}
            "{{field.name}}": self._{{field.name}},  # {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
        })
        return data

{% endfor %}

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 0.0.0.0:12345")
    args = parser.parse_args()
    if args.device is None and args.udp is None:
        parser.print_help()
        exit(1)

    p = PingDevice()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))

    print("Initialized: %s" % p.initialize())

{% for msg in messages["get"]|sort %}
    print("\ntesting get_{{msg}}")
    result = p.get_{{msg}}()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result is not None))

{% endfor %}
    
    print(p)
