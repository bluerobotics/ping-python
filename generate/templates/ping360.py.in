#!/usr/bin/env python3

"""
A device API for the Blue Robotics Ping360 scanning sonar.

This module provides a Python API for managing and interfacing with the Ping360 scanning sonar device.
It extends the functionality of the basic PingDevice class to include sonar-specific commands and processing.
"""

from brping import definitions
from brping import PingDevice
from brping import pingmessage
import time

class Ping360(PingDevice):
    """
    Represents a Ping360 Scanning Sonar from Blue Robotics.

    This class provides methods to operate the Ping360 sonar, enabling control over sonar scanning operations,
    retrieval of sonar images, and configuration of device settings.
    """
    def initialize(self):
        if not PingDevice.initialize(self):
            return False
        if (self.readDeviceInformation() is None):
            return False
        return True

{% for msg in messages["get"]|sort %}
    def get_{{msg}}(self):
        """
        Get a {{msg|replace("get_", "")}} message from the device.\n
        {{messages["get"][msg].description}}\n
        :return: None if there is no reply from the device, otherwise a dictionary with the following keys:\n
{% for field in messages["get"][msg].payload %}
        - {{field.name}}: {{field.description}}{% if field.units %} (Units: {{field.units}}){% endif %}\n
{% endfor %}\n
        :rtype: dict or None
        """
        if self.request(definitions.PING360_{{msg|upper}}) is None:
            return None
        data = ({
{% for field in messages["get"][msg].payload %}
            "{{field.name}}": self._{{field.name}},  # {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
        })
        return data

{% endfor %}
{% for msg in messages["set"]|sort %}
    def {{msg}}(self{% for field in messages["set"][msg].payload %}, {{field.name}}{% endfor %}, verify=True):
        """
        Send a {{msg}} message to the device.\n
        {{messages["set"][msg].description}}\n
        Send the message to write the device parameters, then read the values back from the device.\n
{% for field in messages["set"][msg].payload %}
        :param {{field.name}}: {{field.description}}{% if field.units %} (Units: {{field.units}}){% endif %}\n
        :type {{field.name}}: type\n
{% endfor %}
        :param verify: Specify whether to verify the new parameters by reading them back from the device. Defaults to True.
        :type verify: bool

        :return: True if successful communication with the device (and verification if verify is True), False otherwise.
        :rtype: bool
        """
        m = pingmessage.PingMessage(definitions.PING360_{{msg|upper}})
{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)
        if self.request(definitions.PING360_{{msg|replace("set_", "")|upper}}) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
{% if messages["set"][msg].payload %}
                and ({% for field in messages["set"][msg].payload %}self._{{field.name}} != {{field.name}}{{ " or " if not loop.last }}{% endfor %})):
{% endif %}
            return False
        return True  # success{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

{% for msg in messages["control"]|sort %}
    def control_{{msg}}(self{% for field in messages["control"][msg].payload %}, {{field.name}}{% endfor %}):
        """
        Send a control command ({{msg}}) to the device.\n
{% if messages["control"][msg].description %}
        {{messages["control"][msg].description}}\n
{% endif %}
{% for field in messages["control"][msg].payload %}
        :param {{field.name}}: {{field.description}}{% if field.units %} (Units: {{field.units}}){% endif %}\n
        :type {{field.name}}: type\n
{% endfor %}\n

        :return: None
        :rtype: None
        """
        m = pingmessage.PingMessage(definitions.PING360_{{msg|upper}})
{% for field in messages["control"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

{% for field in messages["control"]["transducer"].payload %}
{% if field.name != "transmit" and field.name != "reserved" %}
    def set_{{field.name}}(self, {{field.name}}):
        """
        Set the {{field.name}} of the transducer.\n
{% if field.description %}
        Description: {{field.description}}\n
{% endif %}
        :param {{field.name}}: The new value for {{field.name}}{% if field.units %} (Units: {{field.units}}){% endif %}.\n
        :type {{field.name}}: type\n

        :return: None
        :rtype: None
        """
        self.control_transducer(
{% for field2 in messages["control"]["transducer"].payload %}
{% if field2.name != "transmit" and field2.name != "reserved" %}
{% if field == field2 %}
            {{field2.name}},
{% else %}
            self._{{field2.name}},
{% endif %}
{% endif %}
{% endfor %}
            0,
            0
        )
        return self.wait_message([definitions.PING360_DEVICE_DATA, definitions.COMMON_NACK], 4.0)

{% endif %}
{% endfor %}

    def readDeviceInformation(self):
        return self.request(definitions.PING360_DEVICE_DATA)

    def transmitAngle(self, angle):
        self.control_transducer(
            0, # reserved
            self._gain_setting,
            angle,
            self._transmit_duration,
            self._sample_period,
            self._transmit_frequency,
            self._number_of_samples,
            1,
            0
        )
        return self.wait_message([definitions.PING360_DEVICE_DATA, definitions.COMMON_NACK], 4.0)
    
    def transmit(self):
        return self.transmitAngle(self._angle)

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=False, type=str, help="Ping device port. E.g: /dev/ttyUSB0")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate. E.g: 115200")
    parser.add_argument('--udp', action="store", required=False, type=str, help="Ping UDP server. E.g: 192.168.2.2:9092")
    args = parser.parse_args()
    if args.device is None and args.udp is None:
        parser.print_help()
        exit(1)

    p = Ping360()
    if args.device is not None:
        p.connect_serial(args.device, args.baudrate)
    elif args.udp is not None:
        (host, port) = args.udp.split(':')
        p.connect_udp(host, int(port))

    print("Initialized: %s" % p.initialize())

    print(p.set_transmit_frequency(800))
    print(p.set_sample_period(80))
    print(p.set_number_of_samples(200))

    tstart_s = time.time()
    for x in range(400):
        p.transmitAngle(x)
    tend_s = time.time()

    print(p)

    print("full scan in %dms, %dHz" % (1000*(tend_s - tstart_s), 400/(tend_s - tstart_s)))

    # turn on auto-scan with 1 grad steps
    p.control_auto_transmit(0,399,1,0)

    tstart_s = time.time()
    # wait for 400 device_data messages to arrive
    for x in range(400):
        p.wait_message([definitions.PING360_DEVICE_DATA])
    tend_s = time.time()

    print("full scan in %dms, %dHz" % (1000*(tend_s - tstart_s), 400/(tend_s - tstart_s)))

    # stop the auto-transmit process
    p.control_motor_off()

    # turn on auto-transmit with 10 grad steps
    p.control_auto_transmit(0,399,10,0)

    tstart_s = time.time()
    # wait for 40 device_data messages to arrive (40 * 10grad steps = 400 grads)
    for x in range(40):
        p.wait_message([definitions.PING360_DEVICE_DATA])
    tend_s = time.time()

    print("full scan in %dms, %dHz" % (1000*(tend_s - tstart_s), 400/(tend_s - tstart_s)))

    p.control_reset(0, 0)
