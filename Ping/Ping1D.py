#!/usr/bin/python -u

# Ping1D.py
# A device API for the Blue Robotics Ping1D echosounder

#~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
#~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from . import PingMessage
import serial
import time

class Ping1D(object):
    def __init__(self, deviceName, baudrate=115200):
        if deviceName is None:
            print("Device name is required")
            return

        try:
            print("Opening %s at %d bps" % (deviceName, baudrate))

            ## Serial object for device communication
            self.iodev = serial.Serial(deviceName, baudrate)
            self.iodev.timeout = 1

        except Exception as e:
            print("Failed to open the given serial port")
            print("\t", e)
            exit(1)

        ## A helper class to take care of decoding the input stream
        self.parser = PingMessage.PingParser()

        ## device id of this Ping1D object, used for dst_device_id in outgoing messages
        self.my_id = 255

    ## Consume rx buffer data until a new message is successfully decoded
    # @return A new PingMessage: as soon as a message is parsed (there may be data remaining in the buffer to be parsed, thus requiring subsequent calls to read())
    # @return None: if the buffer is empty and no message has been parsed
    def read(self):
        while(self.iodev.in_waiting):
            b = self.iodev.read()

            if self.parser.parseByte(ord(b)) == PingMessage.PingParser.NEW_MESSAGE:
                self.handleMessage(self.parser.rxMsg)
                return self.parser.rxMsg
        return None

    ## Write data to device
    def write(self, data):
        return self.iodev.write(data)

    ## Make sure there is a device on the line and read some initial data
    # Return True if the device replies with expected data
    # Return False otherwise
    def initialize(self):
        if self.request(PingMessage.PING1D_VOLTAGE_5) is None:
            return False
        return True

    ## Request the given message ID
    # Return response if it is rxed within timeout period, None otherwise
    # TODO handle nack to exit without blocking
    def request(self, m_id, timeout=0.35):
        msg = PingMessage.PingMessage()
        msg.request_id = m_id
        msg.packMsgData()
        self.write(msg.msgData)
        return self.waitReply(m_id, timeout)

    ## Wait for the device to send a message with the desired message_id for timeout s
    # Return True if a valid message is received from the device with the desired message_id before the timeout period expires
    # Return False otherwise
    def waitReply(self, message_id, timeout=0.5):
        tstart = time.time()
        while(time.time() < tstart + timeout):
            msg = self.read()
            if msg is not None:
                if msg.message_id == message_id:
                    return msg
        return None

    ## Handle an incoming messge from the device
    # Extract message fields into self attributes
    def handleMessage(self, msg):
        if msg.message_id in PingMessage.payloadDict:
            for attr in PingMessage.payloadDict[msg.message_id]["field_names"]:
                setattr(self, attr, getattr(msg, attr))
        else:
            print("Unrecognized message: %d", msg)

    ## Dump object into string representation
    def __repr__(self):
        representation = "---------------------------------------------------------\n~Ping1D Object~"

        attrs = vars(self)
        for attr in sorted(attrs):
            try:
                if attr != 'iodev':
                    representation += "\n  - " + attr + "(hex): " + str([hex(ord(item)) for item in getattr(self, attr)])
                if attr != 'data':
                    representation += "\n  - " + attr + "(string): " + str(getattr(self, attr))
            except:
                representation += "\n  - " + attr + ": " + str(getattr(self, attr))
        return representation

    # Access Methods
    ################
    # Request a message from the device
    # If there is no reply return None, otherwise return a dictionary of the updated values

    ## Device information
    #  Returns a dictionary of the reply payload
    #  @return device_type: Device type. 0: 1D Echosounder
    #  @return device_model: Device model. 0: Ping1D
    #  @return fw_version_major: Firmware version major number.
    #  @return fw_version_minor: Firmware version minor number.
    def get_fw_version(self):
        if self.request(PingMessage.PING1D_FW_VERSION) is None:
            return None
        data = ({
            "device_type": self.device_type, # Device type. 0: 1D Echosounder
            "device_model": self.device_model, # Device model. 0: Ping1D
            "fw_version_major": self.fw_version_major, # Firmware version major number.
            "fw_version_minor": self.fw_version_minor, # Firmware version minor number.
        })
        return data

    ## The device ID.
    #  Returns a dictionary of the reply payload
    #  @return device_id: The device ID (0-254). 255 is reserved for broadcast messages.
    def get_device_id(self):
        if self.request(PingMessage.PING1D_DEVICE_ID) is None:
            return None
        data = ({
            "device_id": self.device_id, # The device ID (0-254). 255 is reserved for broadcast messages.
        })
        return data

    ## The 5V rail voltage.
    #  Returns a dictionary of the reply payload
    #  @return mvolts: Units: mV; The 5V rail voltage.
    def get_voltage_5(self):
        if self.request(PingMessage.PING1D_VOLTAGE_5) is None:
            return None
        data = ({
            "mvolts": self.mvolts, # Units: mV; The 5V rail voltage.
        })
        return data

    ## The speed of sound used for distance calculations.
    #  Returns a dictionary of the reply payload
    #  @return speed_of_sound: Units: mm/s; The speed of sound in the measurement medium. ~1,500,000 mm/s for water.
    def get_speed_of_sound(self):
        if self.request(PingMessage.PING1D_SPEED_OF_SOUND) is None:
            return None
        data = ({
            "speed_of_sound": self.speed_of_sound, # Units: mm/s; The speed of sound in the measurement medium. ~1,500,000 mm/s for water.
        })
        return data

    ## The scan range for acoustic measurements. Measurements returned by the device will lie in the range (scan_start, scan_start + scan_length).
    #  Returns a dictionary of the reply payload
    #  @return scan_start: Units: mm; The beginning of the scan range in mm from the transducer.
    #  @return scan_length: Units: mm; The length of the scan range.
    def get_range(self):
        if self.request(PingMessage.PING1D_RANGE) is None:
            return None
        data = ({
            "scan_start": self.scan_start, # Units: mm; The beginning of the scan range in mm from the transducer.
            "scan_length": self.scan_length, # Units: mm; The length of the scan range.
        })
        return data

    ## The current operating mode of the device. Manual mode allows for manual selection of the gain and scan range.
    #  Returns a dictionary of the reply payload
    #  @return mode_auto: 0: manual mode, 1: auto mode
    def get_mode_auto(self):
        if self.request(PingMessage.PING1D_MODE_AUTO) is None:
            return None
        data = ({
            "mode_auto": self.mode_auto, # 0: manual mode, 1: auto mode
        })
        return data

    ## The interval between acoustic measurements.
    #  Returns a dictionary of the reply payload
    #  @return ping_rate: Units: ms; The interval between acoustic measurements.
    def get_ping_rate(self):
        if self.request(PingMessage.PING1D_PING_RATE) is None:
            return None
        data = ({
            "ping_rate": self.ping_rate, # Units: ms; The interval between acoustic measurements.
        })
        return data

    ## The current gain setting.
    #  Returns a dictionary of the reply payload
    #  @return gain_index: 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    def get_gain_index(self):
        if self.request(PingMessage.PING1D_GAIN_INDEX) is None:
            return None
        data = ({
            "gain_index": self.gain_index, # 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
        })
        return data

    ## The duration of the acoustic activation/transmission.
    #  Returns a dictionary of the reply payload
    #  @return pulse_usec: Units: microseconds; Acoustic pulse duration.
    def get_pulse_usec(self):
        if self.request(PingMessage.PING1D_PULSE_USEC) is None:
            return None
        data = ({
            "pulse_usec": self.pulse_usec, # Units: microseconds; Acoustic pulse duration.
        })
        return data

    ## General information.
    #  Returns a dictionary of the reply payload
    #  @return fw_version_major: Firmware major version.
    #  @return fw_version_minor: Firmware minor version.
    #  @return mvolts: Units: mV; Device supply voltage.
    #  @return ping_rate: Units: ms; The interval between acoustic measurements.
    #  @return gain_index: The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    #  @return mode_auto: The current operating mode of the device. 0: manual mode, 1: auto mode
    def get_general_info(self):
        if self.request(PingMessage.PING1D_GENERAL_INFO) is None:
            return None
        data = ({
            "fw_version_major": self.fw_version_major, # Firmware major version.
            "fw_version_minor": self.fw_version_minor, # Firmware minor version.
            "mvolts": self.mvolts, # Units: mV; Device supply voltage.
            "ping_rate": self.ping_rate, # Units: ms; The interval between acoustic measurements.
            "gain_index": self.gain_index, # The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
            "mode_auto": self.mode_auto, # The current operating mode of the device. 0: manual mode, 1: auto mode
        })
        return data

    ## The distance to target with confidence estimate.
    #  Returns a dictionary of the reply payload
    #  @return distance: Units: mm; Distance to the target.
    #  @return confidence: Units: %; Confidence in the distance measurement.
    def get_distance_simple(self):
        if self.request(PingMessage.PING1D_DISTANCE_SIMPLE) is None:
            return None
        data = ({
            "distance": self.distance, # Units: mm; Distance to the target.
            "confidence": self.confidence, # Units: %; Confidence in the distance measurement.
        })
        return data

    ## 
    #  Returns a dictionary of the reply payload
    #  @return distance: Units: mm; The current return distance determined for the most recent acoustic measurement.
    #  @return confidence: Units: %; Confidence in the most recent range measurement.
    #  @return pulse_usec: Units: us; The acoustic pulse length during acoustic transmission/activation.
    #  @return ping_number: The pulse/measurement count since boot.
    #  @return scan_start: Units: mm; The beginning of the scan region in mm from the transducer.
    #  @return scan_length: Units: mm; The length of the scan region.
    #  @return gain_index: The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    def get_distance(self):
        if self.request(PingMessage.PING1D_DISTANCE) is None:
            return None
        data = ({
            "distance": self.distance, # Units: mm; The current return distance determined for the most recent acoustic measurement.
            "confidence": self.confidence, # Units: %; Confidence in the most recent range measurement.
            "pulse_usec": self.pulse_usec, # Units: us; The acoustic pulse length during acoustic transmission/activation.
            "ping_number": self.ping_number, # The pulse/measurement count since boot.
            "scan_start": self.scan_start, # Units: mm; The beginning of the scan region in mm from the transducer.
            "scan_length": self.scan_length, # Units: mm; The length of the scan region.
            "gain_index": self.gain_index, # The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
        })
        return data

    ## Temperature of the device cpu.
    #  Returns a dictionary of the reply payload
    #  @return temp: Units: cC; The temperature in centi-degrees Centigrade (100 * degrees C).
    def get_processor_temperature(self):
        if self.request(PingMessage.PING1D_PROCESSOR_TEMPERATURE) is None:
            return None
        data = ({
            "temp": self.temp, # Units: cC; The temperature in centi-degrees Centigrade (100 * degrees C).
        })
        return data

    ## Temperature of the on-board thermistor.
    #  Returns a dictionary of the reply payload
    #  @return temp: Units: cC; The temperature in centi-degrees Centigrade (100 * degrees C).
    def get_pcb_temperature(self):
        if self.request(PingMessage.PING1D_PCB_TEMPERATURE) is None:
            return None
        data = ({
            "temp": self.temp, # Units: cC; The temperature in centi-degrees Centigrade (100 * degrees C).
        })
        return data

    ## A profile produced from a single acoustic measurement. The data returned is an array of response strength at even intervals across the scan region. The scan region defined the region between <scan_start> and <scan_start + scan_length> millimeters away from the transducer. A distance measurement to the target is also provided.
    #  Returns a dictionary of the reply payload
    #  @return distance: Units: mm; The current return distance determined for the most recent acoustic measurement.
    #  @return confidence: Units: %; Confidence in the most recent range measurement.
    #  @return pulse_usec: Units: us; The acoustic pulse length during acoustic transmission/activation.
    #  @return ping_number: The pulse/measurement count since boot.
    #  @return scan_start: Units: mm; The beginning of the scan region in mm from the transducer.
    #  @return scan_length: Units: mm; The length of the scan region.
    #  @return gain_index: The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    #  @return num_points: The number of data points for the profile. (The length of the proceeding array)
    #  @return data: An array of return strength measurements taken at regular intervals across the scan region.
    def get_profile(self):
        if self.request(PingMessage.PING1D_PROFILE) is None:
            return None
        data = ({
            "distance": self.distance, # Units: mm; The current return distance determined for the most recent acoustic measurement.
            "confidence": self.confidence, # Units: %; Confidence in the most recent range measurement.
            "pulse_usec": self.pulse_usec, # Units: us; The acoustic pulse length during acoustic transmission/activation.
            "ping_number": self.ping_number, # The pulse/measurement count since boot.
            "scan_start": self.scan_start, # Units: mm; The beginning of the scan region in mm from the transducer.
            "scan_length": self.scan_length, # Units: mm; The length of the scan region.
            "gain_index": self.gain_index, # The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
            "num_points": self.num_points, # The number of data points for the profile. (The length of the proceeding array)
            "data": self.data, # An array of return strength measurements taken at regular intervals across the scan region.
        })
        return data

    ## The protocol version
    #  Returns a dictionary of the reply payload
    #  @return protocol_version: 
    def get_protocol_version(self):
        if self.request(PingMessage.PING1D_PROTOCOL_VERSION) is None:
            return None
        data = ({
            "protocol_version": self.protocol_version, # 
        })
        return data

    # Control Methods
    ###################
    # Write a new control, and read the values back from the device
    # If verify is true, fail if the values read back from the device do not match the controls that were written
    # Return True on success
    # Return False on failure to read values back or on verification failure

    ## Set the device ID.
    #  @param device_id - Device ID (0-254). 255 is reserved for broadcast messages.
    def set_device_id(self, device_id, verify=True):
        m = PingMessage.PingMessage(PingMessage.PING1D_SET_DEVICE_ID)
        m.device_id = device_id
        m.packMsgData()
        self.write(m.msgData)
        if self.request(PingMessage.PING1D_DEVICE_ID) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
              and self.device_id != device_id
              or False):
            return False
        return True # success

    ## Set the scan range for acoustic measurements.
    #  @param scan_start - Units: mm; 
    ## Set the scan range for acoustic measurements.
    #  @param scan_length - Units: mm; The length of the scan range.
    def set_range(self, scan_start, scan_length, verify=True):
        m = PingMessage.PingMessage(PingMessage.PING1D_SET_RANGE)
        m.scan_start = scan_start
        m.scan_length = scan_length
        m.packMsgData()
        self.write(m.msgData)
        if self.request(PingMessage.PING1D_RANGE) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
              and self.scan_start != scan_start
              or self.scan_length != scan_length
              or False):
            return False
        return True # success

    ## Set the speed of sound used for distance calculations.
    #  @param speed_of_sound - Units: mm/s; The speed of sound in the measurement medium. ~1,500,000 mm/s for water.
    def set_speed_of_sound(self, speed_of_sound, verify=True):
        m = PingMessage.PingMessage(PingMessage.PING1D_SET_SPEED_OF_SOUND)
        m.speed_of_sound = speed_of_sound
        m.packMsgData()
        self.write(m.msgData)
        if self.request(PingMessage.PING1D_SPEED_OF_SOUND) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
              and self.speed_of_sound != speed_of_sound
              or False):
            return False
        return True # success

    ## Set automatic or manual mode. Manual mode allows for manual selection of the gain and scan range.
    #  @param mode_auto - 0: manual mode. 1: auto mode.
    def set_mode_auto(self, mode_auto, verify=True):
        m = PingMessage.PingMessage(PingMessage.PING1D_SET_MODE_AUTO)
        m.mode_auto = mode_auto
        m.packMsgData()
        self.write(m.msgData)
        if self.request(PingMessage.PING1D_MODE_AUTO) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
              and self.mode_auto != mode_auto
              or False):
            return False
        return True # success

    ## The interval between acoustic measurements.
    #  @param ping_rate - Units: ms; The interval between acoustic measurements.
    def set_ping_rate(self, ping_rate, verify=True):
        m = PingMessage.PingMessage(PingMessage.PING1D_SET_PING_RATE)
        m.ping_rate = ping_rate
        m.packMsgData()
        self.write(m.msgData)
        if self.request(PingMessage.PING1D_PING_RATE) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
              and self.ping_rate != ping_rate
              or False):
            return False
        return True # success

    ## Set the current gain selection.
    #  @param gain_index - 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    def set_gain_index(self, gain_index, verify=True):
        m = PingMessage.PingMessage(PingMessage.PING1D_SET_GAIN_INDEX)
        m.gain_index = gain_index
        m.packMsgData()
        self.write(m.msgData)
        if self.request(PingMessage.PING1D_GAIN_INDEX) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
              and self.gain_index != gain_index
              or False):
            return False
        return True # success

    ## Enable or disable acoustic measurements.
    #  @param enable - 0: Disable, 1: Enable.
    def set_ping_enable(self, enable, verify=True):
        m = PingMessage.PingMessage(PingMessage.PING1D_SET_PING_ENABLE)
        m.enable = enable
        m.packMsgData()
        self.write(m.msgData)
        if self.request(PingMessage.PING1D_PING_ENABLE) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
              and self.enable != enable
              or False):
            return False
        return True # success


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=True, type=str, help="Ping device port.")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate.")
    args = parser.parse_args()

    p = Ping1D(args.device, args.baudrate)

    print("Initialized: %s" % p.initialize())

    print("\ntesting get_fw_version")
    result = p.get_fw_version()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_device_id")
    result = p.get_device_id()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_voltage_5")
    result = p.get_voltage_5()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_speed_of_sound")
    result = p.get_speed_of_sound()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_range")
    result = p.get_range()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_mode_auto")
    result = p.get_mode_auto()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_ping_rate")
    result = p.get_ping_rate()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_gain_index")
    result = p.get_gain_index()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_pulse_usec")
    result = p.get_pulse_usec()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_general_info")
    result = p.get_general_info()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_distance_simple")
    result = p.get_distance_simple()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_distance")
    result = p.get_distance()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_processor_temperature")
    result = p.get_processor_temperature()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_pcb_temperature")
    result = p.get_pcb_temperature()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_profile")
    result = p.get_profile()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting get_protocol_version")
    result = p.get_protocol_version()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

    print("\ntesting set_device_id")
    print("  > > pass: %s < <" % p.set_device_id(43))
    print("\ntesting set_range")
    print("  > > pass: %s < <" % p.set_range(1000, 2000))
    print("\ntesting set_speed_of_sound")
    print("  > > pass: %s < <" % p.set_speed_of_sound(1444000))
    print("\ntesting set_mode_auto")
    print("  > > pass: %s < <" % p.set_mode_auto(False))
    print("\ntesting set_ping_rate")
    print("  > > pass: %s < <" % p.set_ping_rate(36))
    print("\ntesting set_gain_index")
    print("  > > pass: %s < <" % p.set_gain_index(3))

    # Not implemented
    # print("testing set_ping_enable")
    # print("  > > pass: %s < <" % p.set_ping_enable(0))

    print(p)
